import { parseURL, } from '@paperback/types';
import UserAgent from 'user-agents';
export class MockRequestManager {
    selectorRegistry;
    registeredInterceptors;
    userAgent;
    constructor(selectorRegistry) {
        this.selectorRegistry = selectorRegistry;
        this.registeredInterceptors = [];
        this.userAgent = new UserAgent({ deviceCategory: 'mobile' }).toString();
    }
    registerInterceptor(interceptorId, interceptRequestSelectorId, interceptResponseSelectorId) {
        this.unregisterInterceptor(interceptorId);
        this.registeredInterceptors.push({
            interceptorId,
            interceptRequestSelectorId,
            interceptResponseSelectorId,
        });
    }
    unregisterInterceptor(interceptorId) {
        for (let i = 0; i < this.registeredInterceptors.length; i++) {
            const { interceptorId: registeredInterceptorId } = this.registeredInterceptors[i];
            if (interceptorId == registeredInterceptorId) {
                this.registeredInterceptors.splice(i, 1);
                return;
            }
        }
    }
    setRedirectHandler() { }
    async getDefaultUserAgent() {
        return this.userAgent;
    }
    async scheduleRequest(request) {
        let finalRequest = request;
        for (const interceptor of this.registeredInterceptors) {
            const requestInterceptor = this.selectorRegistry.selector(interceptor.interceptRequestSelectorId);
            finalRequest = await requestInterceptor(request);
        }
        let requestBody = undefined;
        if (finalRequest.body) {
            const rawBody = finalRequest.body;
            switch (typeof rawBody) {
                case 'string': {
                    requestBody = rawBody;
                    break;
                }
                case 'object': {
                    if (rawBody instanceof ArrayBuffer) {
                        requestBody = rawBody;
                    }
                    else {
                        requestBody = Object.keys(rawBody).reduce((formData, key) => {
                            const value = rawBody[key];
                            if (typeof value === 'string' || value instanceof Blob) {
                                formData.append(key, value);
                            }
                            else if (value !== undefined && value !== null) {
                                formData.append(key, String(value));
                            }
                            return formData;
                        }, new FormData());
                    }
                    break;
                }
                default: {
                    break;
                }
            }
        }
        const requestHeaders = finalRequest.headers ?? {};
        if (finalRequest.cookies) {
            const rawCookies = finalRequest.cookies;
            requestHeaders['Cookie'] = Object.keys(finalRequest.cookies)
                .reduce((headerValue, cookieKey) => `${headerValue} ${cookieKey}=${rawCookies[cookieKey]};`, '')
                .trim();
        }
        const fetchResponse = await fetch(finalRequest.url, {
            method: finalRequest.method,
            body: requestBody ?? null,
            headers: requestHeaders,
        });
        const responseHeaders = {};
        for (const [name, value] of fetchResponse.headers.entries()) {
            responseHeaders[name] = value;
        }
        const responseCookies = [];
        for (const cookieString of fetchResponse.headers.getSetCookie()) {
            const properties = cookieString.split(';');
            const [name, value] = properties.shift().split('=');
            let domain;
            let path;
            let expires;
            for (const str of properties) {
                const [name, value] = str.split('=');
                switch (name.toLowerCase()) {
                    case 'expires': {
                        expires = new Date(value);
                        continue;
                    }
                    case 'max-age': {
                        expires = new Date(Date.now() + Number(value) * 1000);
                        continue;
                    }
                    case 'domain': {
                        domain = value;
                        continue;
                    }
                    default: {
                        continue;
                    }
                }
            }
            responseCookies.push({
                name: name,
                value: value,
                domain: domain ?? parseURL(fetchResponse.url).hostname,
                path: path ?? '/',
                expires: expires ?? new Date(),
            });
        }
        const finalResponse = {
            url: fetchResponse.url,
            headers: responseHeaders,
            status: fetchResponse.status,
            cookies: responseCookies,
        };
        let finalArrayBuffer = await fetchResponse.arrayBuffer();
        for (let i = this.registeredInterceptors.length - 1; i >= 0; i--) {
            const { interceptResponseSelectorId } = this.registeredInterceptors[i];
            const responseInterceptor = this.selectorRegistry.selector(interceptResponseSelectorId);
            finalArrayBuffer = await responseInterceptor(finalRequest, finalResponse, finalArrayBuffer);
        }
        return [finalResponse, finalArrayBuffer];
    }
}
//# sourceMappingURL=RequestManager.js.map