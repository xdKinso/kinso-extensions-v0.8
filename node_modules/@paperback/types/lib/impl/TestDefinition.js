import { SourceIntents } from '../impl/SourceInfo.js';
import { implementsChapterProviding } from './interfaces/ChapterProviding.js';
import { implementsSearchResultsProviding, } from './interfaces/SearchResultsProviding.js';
import { expect } from 'chai';
// Test Suite class
export class TestSuite {
    state = {};
    testCases = [];
    suiteName;
    constructor(name) {
        this.suiteName = name;
    }
    // Register a test case
    test(name, fn) {
        this.testCases.push({ name, fn });
    }
    // Run all test cases sequentially
    async run() {
        console.log(`\nðŸ§ª Running test suite: ${this.suiteName}`);
        console.log('='.repeat(50));
        const startTime = Date.now();
        const testResults = [];
        let passed = 0;
        let failed = 0;
        for (const testCase of this.testCases) {
            const testStartTime = Date.now();
            let testResult;
            try {
                const returnValue = await testCase.fn();
                const duration = Date.now() - testStartTime;
                testResult = {
                    name: testCase.name,
                    passed: true,
                    duration,
                    returnValue,
                };
                passed++;
                console.log(`âœ… ${testCase.name} (${duration}ms)`);
            }
            catch (error) {
                const duration = Date.now() - testStartTime;
                testResult = {
                    name: testCase.name,
                    passed: false,
                    error: error,
                    duration,
                };
                failed++;
                console.log(`âŒ ${testCase.name} (${duration}ms)`);
                console.log(`   Error: ${error.message}`);
            }
            testResults.push(testResult);
        }
        const totalDuration = Date.now() - startTime;
        const suiteResult = {
            suiteName: this.suiteName,
            passed,
            failed,
            total: this.testCases.length,
            duration: totalDuration,
            testResults,
        };
        this.printSummary(suiteResult);
        return suiteResult;
    }
    printSummary(result) {
        console.log('\nðŸ“Š Test Summary:');
        console.log(`   Total: ${result.total}`);
        console.log(`   Passed: ${result.passed}`);
        console.log(`   Failed: ${result.failed}`);
        console.log(`   Duration: ${result.duration}ms`);
        if (result.failed > 0) {
            console.log(`\nâŒ Suite "${result.suiteName}" failed`);
        }
        else {
            console.log(`\nâœ… Suite "${result.suiteName}" passed`);
        }
    }
}
export const registerDefaultTests = function (suite, extension, extensionInfo, testData = {}) {
    registerDefaultInitialisationTests(suite, extension);
    let sourceCapabilities = 0;
    if (Array.isArray(extensionInfo.capabilities)) {
        sourceCapabilities = extensionInfo.capabilities.reduce((a, b) => a | b, sourceCapabilities);
    }
    else {
        sourceCapabilities = extensionInfo.capabilities;
    }
    if (sourceCapabilities & SourceIntents.SEARCH_RESULTS_PROVIDING) {
        if (implementsSearchResultsProviding(extension)) {
            registerDefaultSearchResultsProvidingSourceTests(suite, extension, testData);
        }
        else {
            throw new Error(`extension does not implement 'SearchResultsProviding' but has the 'SEARCH_RESULTS_PROVIDING' capability`);
        }
    }
    registerDefaultMangaProvidingSourceTests(suite, extension, testData);
    if (sourceCapabilities & SourceIntents.CHAPTER_PROVIDING) {
        if (implementsChapterProviding(extension)) {
            registerDefaultChapterProvidingSourceTests(suite, extension, testData);
        }
        else {
            throw new Error(`extension does not implement 'ChapterProviding' but has the 'CHAPTER_PROVIDING' capability`);
        }
    }
};
export const registerDefaultInitialisationTests = function (suite, extension) {
    suite.test('initialisation', async () => {
        await extension.initialise();
    });
};
const STATE_KEY = {
    SearchResultsProviding: {
        getSearchFilters: 'SearchResultsProviding.getSearchFilters',
        getSearchResults: 'SearchResultsProviding.getSearchResults',
        getSortingOptions: 'SearchResultsProviding.getSortingOptions',
    },
    MangaProviding: {
        getMangaDetails: 'MangaProviding.getMangaDetails',
    },
    ChapterProviding: {
        getChapters: 'ChapterProviding.getChapters',
        getChapterDetails: 'ChapterProviding.getChapterDetails',
    },
};
export const registerDefaultSearchResultsProvidingSourceTests = function (suite, extension, { searchResultsProviding: testData, }) {
    suite.test('getSearchFilters', async () => {
        expect(extension).to.have.property('getSearchFilters');
        const searchFilters = await extension.getSearchFilters();
        expect(searchFilters).to.not.be.undefined;
        suite.state[STATE_KEY.SearchResultsProviding.getSearchFilters] =
            searchFilters;
    });
    if ('getSortingOptions' in extension) {
        suite.test('getSortingOptions', async () => {
            let params = testData?.getSortingOptions;
            if (!params) {
                const searchFilters = suite.state[STATE_KEY.SearchResultsProviding.getSearchFilters];
                params = [{ title: '', filters: searchFilters ?? [] }];
            }
            const sortingOptions = await extension.getSortingOptions(...params);
            expect(sortingOptions).not.empty;
            suite.state[STATE_KEY.SearchResultsProviding.getSortingOptions] =
                sortingOptions;
        });
    }
    suite.test('getSearchResults', async () => {
        expect(extension).to.have.property('getSearchResults');
        let params = testData?.getSearchResults;
        if (!params) {
            const searchFilters = suite.state[STATE_KEY.SearchResultsProviding.getSearchFilters];
            const sortingOptions = suite.state[STATE_KEY.SearchResultsProviding.getSortingOptions];
            params = [
                { title: '', filters: searchFilters ?? [] },
                undefined,
                sortingOptions?.[0],
            ];
        }
        const searchResults = await extension.getSearchResults(...params);
        expect(searchResults).not.empty;
        expect(searchResults.items).not.be.empty;
        suite.state[STATE_KEY.SearchResultsProviding.getSearchResults] =
            searchResults;
    });
};
export const registerDefaultMangaProvidingSourceTests = function (suite, extension, { mangaProviding: testData }) {
    suite.test('getMangaDetails', async () => {
        expect(extension).to.have.property('getMangaDetails');
        let params = testData?.getMangaDetails;
        if (!params) {
            const searchResults = suite.state[STATE_KEY.SearchResultsProviding.getSearchResults];
            if (searchResults?.items[0]?.mangaId) {
                params = [searchResults.items[0].mangaId];
            }
            else {
                throw new Error('No `mangaId` provided in test data. Unable to infer from `SearchResultsProviding.getSearchResults`');
            }
        }
        const mangaDetails = await extension.getMangaDetails(...params);
        expect(mangaDetails).to.not.be.undefined;
        expect(mangaDetails.mangaInfo).to.not.be.undefined;
        suite.state[STATE_KEY.MangaProviding.getMangaDetails] = mangaDetails;
    });
};
export const registerDefaultChapterProvidingSourceTests = function (suite, extension, { chapterProviding: testData }) {
    suite.test('getChapters', async () => {
        expect(extension).to.have.property('getChapters');
        let params = testData?.getChapters;
        if (!params) {
            const sourceManga = suite.state[STATE_KEY.MangaProviding.getMangaDetails];
            if (sourceManga) {
                params = [sourceManga];
            }
            else {
                throw new Error('No `sourceManga` provided in test data. Unable to infer from `MangaProviding.getMangaDetails`');
            }
        }
        const chapters = await extension.getChapters(...params);
        expect(chapters).to.not.be.empty;
        suite.state[STATE_KEY.ChapterProviding.getChapters] = chapters;
    });
    suite.test('getChapterDetails', async () => {
        expect(extension).to.have.property('getChapterDetails');
        let params = testData?.getChapterDetails;
        if (!params) {
            const chapters = suite.state[STATE_KEY.ChapterProviding.getChapters];
            if (chapters?.[0]) {
                params = [chapters[0]];
            }
            else {
                throw new Error('No `sourceManga` provided in test data. Unable to infer from `MangaProviding.getMangaDetails`');
            }
        }
        const chapterDetails = await extension.getChapterDetails(...params);
        expect(chapterDetails).to.not.be.undefined;
        suite.state[STATE_KEY.ChapterProviding.getChapterDetails] = chapterDetails;
    });
};
//# sourceMappingURL=TestDefinition.js.map