/* eslint-disable @typescript-eslint/prefer-literal-enum-member */
/* eslint-disable @typescript-eslint/ban-ts-comment */
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/no-namespace */
import { BasicRateLimiter, CookieStorageInterceptor, PaperbackInterceptor, } from '../../index.js';
/**
 * @deprecated Use {@link PaperbackExtensionBase}
 */
export class Source {
    cheerio;
    constructor(cheerio) {
        this.cheerio = cheerio;
    }
    /**
     * @deprecated use {@link Source.getSearchResults getSearchResults} instead
     */
    searchRequest(query, metadata) {
        return this.getSearchResults(query, metadata);
    }
    /**
     * @deprecated use {@link Source.getSearchTags} instead
     */
    async getTags() {
        return this.getSearchTags?.() ?? [];
    }
}
// Many sites use '[x] time ago' - Figured it would be good to handle these cases in general
export function convertTime(timeAgo) {
    let time;
    let trimmed = Number((/\d*/.exec(timeAgo) ?? [])[0]);
    trimmed = trimmed == 0 && timeAgo.includes('a') ? 1 : trimmed;
    if (timeAgo.includes('minutes')) {
        time = new Date(Date.now() - trimmed * 60000);
    }
    else if (timeAgo.includes('hours')) {
        time = new Date(Date.now() - trimmed * 3600000);
    }
    else if (timeAgo.includes('days')) {
        time = new Date(Date.now() - trimmed * 86400000);
    }
    else if (timeAgo.includes('year') || timeAgo.includes('years')) {
        time = new Date(Date.now() - trimmed * 31556952000);
    }
    else {
        time = new Date(Date.now());
    }
    return time;
}
/**
 * When a function requires a POST body, it always should be defined as a JsonObject
 * and then passed through this function to ensure that it's encoded properly.
 * @param obj
 */
export function urlEncodeObject(obj) {
    const ret = {};
    for (const entry of Object.entries(obj)) {
        ret[encodeURIComponent(entry[0])] = encodeURIComponent(entry[1]);
    }
    return ret;
}
export var HomeSectionType;
(function (HomeSectionType) {
    HomeSectionType["singleRowNormal"] = "singleRowNormal";
    HomeSectionType["singleRowLarge"] = "singleRowLarge";
    HomeSectionType["doubleRow"] = "doubleRow";
    HomeSectionType["featured"] = "featured";
})(HomeSectionType || (HomeSectionType = {}));
export var SourceIntents;
(function (SourceIntents) {
    SourceIntents[SourceIntents["MANGA_CHAPTERS"] = 1] = "MANGA_CHAPTERS";
    SourceIntents[SourceIntents["MANGA_TRACKING"] = 2] = "MANGA_TRACKING";
    SourceIntents[SourceIntents["HOMEPAGE_SECTIONS"] = 4] = "HOMEPAGE_SECTIONS";
    SourceIntents[SourceIntents["COLLECTION_MANAGEMENT"] = 8] = "COLLECTION_MANAGEMENT";
    SourceIntents[SourceIntents["CLOUDFLARE_BYPASS_REQUIRED"] = 16] = "CLOUDFLARE_BYPASS_REQUIRED";
    SourceIntents[SourceIntents["SETTINGS_UI"] = 32] = "SETTINGS_UI";
})(SourceIntents || (SourceIntents = {}));
/**
 * A content rating to be attributed to each source.
 */
export var ContentRating;
(function (ContentRating) {
    ContentRating["EVERYONE"] = "EVERYONE";
    ContentRating["MATURE"] = "MATURE";
    ContentRating["ADULT"] = "ADULT";
})(ContentRating || (ContentRating = {}));
export var BadgeColor;
(function (BadgeColor) {
    BadgeColor["BLUE"] = "default";
    BadgeColor["GREEN"] = "success";
    BadgeColor["GREY"] = "info";
    BadgeColor["YELLOW"] = "warning";
    BadgeColor["RED"] = "danger";
})(BadgeColor || (BadgeColor = {}));
const AppCompat = {};
AppCompat.createSourceStateManager = function () {
    return {
        keychain: {
            async store(key, value) {
                Application.setSecureState(value, key);
            },
            async retrieve(key) {
                return Application.getSecureState(key);
            },
        },
        async store(key, value) {
            Application.setState(value, key);
        },
        async retrieve(key) {
            return Application.getState(key);
        },
    };
};
export function convert08RequestTo09Request(request) {
    let url = request.url;
    if (request.param) {
        url += request.param;
    }
    const cookies = {};
    for (const cookie of request.cookies ?? []) {
        cookies[cookie.name] = cookie.value;
    }
    return {
        url,
        method: request.method,
        body: request.data,
        headers: request.headers,
        cookies,
    };
}
export function convert09RequestTo08Request(request) {
    return {
        url: request.url,
        method: request.method,
        headers: request.headers ?? {},
        cookies: Object.keys(request.cookies ?? {}).map((x) => ({
            name: x,
            value: request.cookies[x],
            domain: '',
        })),
        data: request.body,
    };
}
AppCompat.createRequestManager = function (info) {
    const interceptor = new (class extends PaperbackInterceptor {
        legacyInterceptor;
        constructor(legacyInterceptor) {
            super('main');
            this.legacyInterceptor = legacyInterceptor;
        }
        async interceptRequest(request) {
            if (!this.legacyInterceptor)
                return request;
            const oldRequest = convert09RequestTo08Request(request);
            const interceptedRequest = await this.legacyInterceptor.interceptRequest(oldRequest);
            return convert08RequestTo09Request(interceptedRequest);
        }
        async interceptResponse(request, response, data) {
            if (!this.legacyInterceptor)
                return data;
            return data;
        }
    })(info.interceptor);
    const rateLimiter = new BasicRateLimiter('rateLimit', {
        numberOfRequests: info.requestsPerSecond ?? 2,
        bufferInterval: 1,
        ignoreImages: true,
    });
    const cookieStore = new CookieStorageInterceptor({ storage: 'memory' });
    interceptor.registerInterceptor();
    rateLimiter.registerInterceptor();
    cookieStore.registerInterceptor();
    return {
        __backing_interceptor: interceptor,
        __backing_rateLimit: rateLimiter,
        __backing_cookieStore: cookieStore,
        interceptor: info.interceptor,
        cookieStore: {
            // @ts-expect-error
            getAllCookies() {
                return cookieStore.cookies;
            },
            addCookie(cookies) {
                cookieStore.setCookie(cookies);
            },
            removeCookie(cookie) {
                cookieStore.deleteCookie(cookie);
            },
        },
        async getDefaultUserAgent() {
            return Application.getDefaultUserAgent();
        },
        requestsPerSecond: info.requestsPerSecond ?? 2,
        requestTimeout: info.requestTimeout ?? 30_000,
        async schedule(request) {
            const finalRequest = convert08RequestTo09Request(request);
            console.log('[COMPAT] SCHEDULING REQUEST TO ' + finalRequest.url);
            const [response, data] = await Application.scheduleRequest(finalRequest);
            return {
                request,
                headers: response.headers,
                status: response.status,
                data: Application.arrayBufferToUTF8String(data),
                get rawData() {
                    return new Uint8Array(data);
                },
            };
        },
    };
};
globalThis.App = new Proxy(AppCompat, {
    get(target, p) {
        if (target[p]) {
            return target[p];
        }
        if (typeof p === 'string' && p.startsWith('create')) {
            if (p.startsWith('createDUI')) {
                const type = p.slice(6);
                return (anyProps) => {
                    return Object.defineProperty(anyProps, 'type', {
                        enumerable: true,
                        value: type,
                    });
                };
            }
            return (anyProps) => anyProps;
        }
        return undefined;
    },
});
//# sourceMappingURL=types.js.map